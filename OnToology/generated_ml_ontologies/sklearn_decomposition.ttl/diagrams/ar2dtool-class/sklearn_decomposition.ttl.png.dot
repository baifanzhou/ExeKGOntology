digraph ar2dtool_diagram { 
rankdir=LR;
size="1501"
node [shape = rectangle, color="orange"]; "ml:NMF" "ml:KernelPCA" "ml:SparseCoder" "ml:LatentDirichletAllocation" "ml:DictionaryLearning" "ml:MiniBatchDictionaryLearning" "ml:PCA" "ml:SparsePCA" "ml:DecompositionModule" "ml:Decomposition" "ml:TruncatedSVD" "ml:IncrementalPCA" "ml:FastICA" "ml:MiniBatchNMF" "ml:MiniBatchSparsePCA" "ml:FactorAnalysis" ; /*classes style*/
	"ml:hasParamVerbose" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTransformAlgorithm" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFreshRestartsMaxIter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlpha" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:LatentDirichletAllocation" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:hasParamTransformMaxIter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamL1Ratio" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxNoImprovement" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCallback" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSvdSolver" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlgorithm" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSvdMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTransformNNonzeroCoefs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPerpTol" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:FactorAnalysis" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:hasParamFun" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamRemoveZeroEig" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:KernelPCA" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:hasParamNOversamples" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFitAlgorithm" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCodeInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamRandomState" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxDocUpdateIter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDegree" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLearningDecay" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDocTopicPrior" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamRidgeAlpha" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamShuffle" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:DictionaryLearning" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:hasParamDictInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFunArgs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFreshRestarts" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDictionary" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCopyX" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamIteratedPower" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCoef0" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:TruncatedSVD" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:IncrementalPCA" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:hasParamInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:MiniBatchDictionaryLearning" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:hasParamRotation" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlphaH" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamVInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:NMF" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:hasParamLearningOffset" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBatchSize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNComponents" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamKernelParams" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNIter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:SparseCoder" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:hasParamEvaluateEvery" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMeanChangeTol" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxIter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTransformAlpha" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamKernel" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSolver" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:MiniBatchNMF" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:hasParamUInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLearningMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSplitSign" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEigenSolver" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTol" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:SparsePCA" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:hasParamGamma" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWhitenSolver" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFitInverseTransform" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasDecompositionMethod" -> "ml:hasPrepareTransformerMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWhiten" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBetaLoss" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTotalSamples" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCopy" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamForgetFactor" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPositiveDict" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTopicWordPrior" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNJobs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:MiniBatchSparsePCA" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:hasParamPowerIterationNormalizer" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlphaW" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:PCA" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:FastICA" -> "ml:DecompositionModule" [ label = "ds:hasModule" ];
	"ml:hasParamPositiveCode" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:MiniBatchNMF" -> "xsd:int" [ label = "ml:hasParamFreshRestartsMaxIter" ];
	"ml:KernelPCA" -> "xsd:boolean" [ label = "ml:hasParamRemoveZeroEig" ];
	"ml:KernelPCA" -> "xsd:boolean" [ label = "ml:hasParamFitInverseTransform" ];
	"ml:DictionaryLearning" -> "xsd:boolean" [ label = "ml:hasParamPositiveCode" ];
	"ml:Decomposition" -> "ml:SparsePCA" [ label = "ml:hasDecompositionMethod" ];
	"ml:KernelPCA" -> "xsd:string" [ label = "ml:hasParamEigenSolver" ];
	"ml:KernelPCA" -> "xsd:string" [ label = "ml:hasParamKernelParams" ];
	"ml:MiniBatchNMF" -> "xsd:boolean" [ label = "ml:hasParamFreshRestarts" ];
	"ml:MiniBatchNMF" -> "xsd:float" [ label = "ml:hasParamBetaLoss" ];
	"ml:DictionaryLearning" -> "xsd:int" [ label = "ml:hasParamTransformMaxIter" ];
	"ml:LatentDirichletAllocation" -> "xsd:float" [ label = "ml:hasParamLearningDecay" ];
	"ml:DictionaryLearning" -> "xsd:float" [ label = "ml:hasParamAlpha" ];
	"ml:KernelPCA" -> "xsd:boolean" [ label = "ml:hasParamCopyX" ];
	"ml:MiniBatchSparsePCA" -> "xsd:string" [ label = "ml:hasParamMethod" ];
	"ml:DictionaryLearning" -> "xsd:string" [ label = "ml:hasParamDictInit" ];
	"ml:DictionaryLearning" -> "xsd:boolean" [ label = "ml:hasParamSplitSign" ];
	"ml:PCA" -> "xsd:string" [ label = "ml:hasParamPowerIterationNormalizer" ];
	"ml:KernelPCA" -> "xsd:float" [ label = "ml:hasParamGamma" ];
	"ml:KernelPCA" -> "xsd:float" [ label = "ml:hasParamDegree" ];
	"ml:SparseCoder" -> "xsd:string" [ label = "ml:hasParamDictionary" ];
	"ml:MiniBatchNMF" -> "xsd:string" [ label = "ml:hasParamInit" ];
	"ml:IncrementalPCA" -> "xsd:int" [ label = "ml:hasParamBatchSize" ];
	"ml:IncrementalPCA" -> "xsd:string" [ label = "ml:hasParamNComponents" ];
	"ml:MiniBatchDictionaryLearning" -> "xsd:string" [ label = "ml:hasParamNJobs" ];
	"ml:DictionaryLearning" -> "xsd:string" [ label = "ml:hasParamTransformAlgorithm" ];
	"ml:LatentDirichletAllocation" -> "xsd:int" [ label = "ml:hasParamTotalSamples" ];
	"ml:FactorAnalysis" -> "xsd:string" [ label = "ml:hasParamSvdMethod" ];
	"ml:FastICA" -> "xsd:string" [ label = "ml:hasParamAlgorithm" ];
	"ml:FastICA" -> "xsd:float" [ label = "ml:hasParamTol" ];
	"ml:FastICA" -> "xsd:string" [ label = "ml:hasParamWInit" ];
	"ml:TruncatedSVD" -> "xsd:int" [ label = "ml:hasParamNIter" ];
	"ml:MiniBatchNMF" -> "xsd:float" [ label = "ml:hasParamAlphaH" ];
	"ml:FactorAnalysis" -> "xsd:int" [ label = "ml:hasParamIteratedPower" ];
	"ml:MiniBatchNMF" -> "xsd:float" [ label = "ml:hasParamForgetFactor" ];
	"ml:FastICA" -> "xsd:string" [ label = "ml:hasParamFunArgs" ];
	"ml:FactorAnalysis" -> "xsd:string" [ label = "ml:hasParamRotation" ];
	"ml:NMF" -> "xsd:string" [ label = "ml:hasParamSolver" ];
	"ml:DictionaryLearning" -> "xsd:string" [ label = "ml:hasParamCodeInit" ];
	"ml:LatentDirichletAllocation" -> "xsd:string" [ label = "ml:hasParamLearningMethod" ];
	"ml:KernelPCA" -> "xsd:string" [ label = "ml:hasParamKernel" ];
	"ml:MiniBatchNMF" -> "xsd:float" [ label = "ml:hasParamAlphaW" ];
	"ml:MiniBatchNMF" -> "xsd:float" [ label = "ml:hasParamL1Ratio" ];
	"ml:DictionaryLearning" -> "xsd:boolean" [ label = "ml:hasParamPositiveDict" ];
	"ml:MiniBatchDictionaryLearning" -> "xsd:int" [ label = "ml:hasParamMaxNoImprovement" ];
	"ml:MiniBatchDictionaryLearning" -> "xsd:boolean" [ label = "ml:hasParamShuffle" ];
	"ml:FastICA" -> "xsd:boolean" [ label = "ml:hasParamWhiten" ];
	"ml:LatentDirichletAllocation" -> "xsd:float" [ label = "ml:hasParamDocTopicPrior" ];
	"ml:LatentDirichletAllocation" -> "xsd:float" [ label = "ml:hasParamPerpTol" ];
	"ml:FastICA" -> "xsd:int" [ label = "ml:hasParamMaxIter" ];
	"ml:KernelPCA" -> "xsd:float" [ label = "ml:hasParamCoef0" ];
	"ml:FactorAnalysis" -> "xsd:boolean" [ label = "ml:hasParamCopy" ];
	"ml:PCA" -> "xsd:int" [ label = "ml:hasParamNOversamples" ];
	"ml:DictionaryLearning" -> "xsd:boolean" [ label = "ml:hasParamVerbose" ];
	"ml:DictionaryLearning" -> "xsd:float" [ label = "ml:hasParamTransformAlpha" ];
	"ml:SparsePCA" -> "xsd:string" [ label = "ml:hasParamUInit" ];
	"ml:NMF" -> "xsd:int" [ label = "ml:hasParamRandomState" ];
	"ml:PCA" -> "xsd:string" [ label = "ml:hasParamSvdSolver" ];
	"ml:FastICA" -> "xsd:string" [ label = "ml:hasParamWhitenSolver" ];
	"ml:LatentDirichletAllocation" -> "xsd:float" [ label = "ml:hasParamTopicWordPrior" ];
	"ml:DictionaryLearning" -> "xsd:int" [ label = "ml:hasParamTransformNNonzeroCoefs" ];
	"ml:FastICA" -> "xsd:string" [ label = "ml:hasParamFun" ];
	"ml:LatentDirichletAllocation" -> "xsd:int" [ label = "ml:hasParamEvaluateEvery" ];
	"ml:SparsePCA" -> "xsd:string" [ label = "ml:hasParamVInit" ];
	"ml:DictionaryLearning" -> "xsd:string" [ label = "ml:hasParamCallback" ];
	"ml:DictionaryLearning" -> "xsd:string" [ label = "ml:hasParamFitAlgorithm" ];
	"ml:MiniBatchSparsePCA" -> "xsd:float" [ label = "ml:hasParamRidgeAlpha" ];
	"ml:LatentDirichletAllocation" -> "xsd:float" [ label = "ml:hasParamMeanChangeTol" ];
	"ml:LatentDirichletAllocation" -> "xsd:float" [ label = "ml:hasParamLearningOffset" ];
	"ml:LatentDirichletAllocation" -> "xsd:int" [ label = "ml:hasParamMaxDocUpdateIter" ];

}
