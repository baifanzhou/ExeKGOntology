digraph ar2dtool_diagram { 
rankdir=LR;
size="1501"
node [shape = rectangle, color="orange"]; "ml:OrdinalEncoder" "ml:SplineTransformer" "ml:LabelBinarizer" "ml:MinMaxScaler" "ml:StandardScaler" "ml:Binarizer" "ml:DataProcessing" "ml:RobustScaler" "ml:FunctionTransformer" "ml:Normalizer" "ml:PowerTransformer" "ml:TargetEncoder" "ml:QuantileTransformer" "ml:OneHotEncoder" "ml:PolynomialFeatures" "ml:KBinsDiscretizer" ; /*classes style*/
	"ml:hasParamCv" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStandardize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFeatureNamesOut" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFunc" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamOutputDistribution" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNorm" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNKnots" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStrategy" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInteractionOnly" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamUnitVariance" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInverseFunc" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasDataProcessingMethod" -> "ml:hasPrepareTransformerMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamOrder" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamKwArgs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamKnots" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNBins" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxCategories" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamRandomState" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDegree" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamShuffle" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSparseOutput" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSmooth" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamHandleUnknown" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDtype" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCategories" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEncode" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCheckInverse" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWithCentering" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamIgnoreImplicitZeros" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamQuantileRange" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFeatureRange" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamUnknownValue" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamIncludeBias" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSubsample" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamExtrapolation" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDrop" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEncodedMissingValue" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamThreshold" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamClip" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInvKwArgs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinFrequency" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFeatureNameCombiner" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAcceptSparse" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWithScaling" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCopy" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNQuantiles" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNegLabel" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTargetType" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWithStd" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWithMean" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamValidate" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPosLabel" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:MinMaxScaler" -> "xsd:string" [ label = "ml:hasParamFeatureRange" ];
	"ml:OneHotEncoder" -> "xsd:string" [ label = "ml:hasParamHandleUnknown" ];
	"ml:PolynomialFeatures" -> "xsd:boolean" [ label = "ml:hasParamInteractionOnly" ];
	"ml:RobustScaler" -> "xsd:boolean" [ label = "ml:hasParamUnitVariance" ];
	"ml:MinMaxScaler" -> "xsd:boolean" [ label = "ml:hasParamClip" ];
	"ml:FunctionTransformer" -> "xsd:string" [ label = "ml:hasParamKwArgs" ];
	"ml:StandardScaler" -> "xsd:boolean" [ label = "ml:hasParamWithStd" ];
	"ml:RobustScaler" -> "xsd:boolean" [ label = "ml:hasParamWithScaling" ];
	"ml:TargetEncoder" -> "xsd:int" [ label = "ml:hasParamCv" ];
	"ml:OneHotEncoder" -> "xsd:string" [ label = "ml:hasParamFeatureNameCombiner" ];
	"ml:QuantileTransformer" -> "xsd:string" [ label = "ml:hasParamOutputDistribution" ];
	"ml:TargetEncoder" -> "xsd:float" [ label = "ml:hasParamSmooth" ];
	"ml:QuantileTransformer" -> "xsd:int" [ label = "ml:hasParamNQuantiles" ];
	"ml:SplineTransformer" -> "xsd:string" [ label = "ml:hasParamExtrapolation" ];
	"ml:PowerTransformer" -> "xsd:string" [ label = "ml:hasParamMethod" ];
	"ml:FunctionTransformer" -> "xsd:boolean" [ label = "ml:hasParamValidate" ];
	"ml:FunctionTransformer" -> "xsd:string" [ label = "ml:hasParamFeatureNamesOut" ];
	"ml:SplineTransformer" -> "xsd:int" [ label = "ml:hasParamNKnots" ];
	"ml:OrdinalEncoder" -> "xsd:int" [ label = "ml:hasParamEncodedMissingValue" ];
	"ml:SplineTransformer" -> "xsd:string" [ label = "ml:hasParamKnots" ];
	"ml:PowerTransformer" -> "xsd:boolean" [ label = "ml:hasParamStandardize" ];
	"ml:KBinsDiscretizer" -> "xsd:int" [ label = "ml:hasParamSubsample" ];
	"ml:QuantileTransformer" -> "xsd:boolean" [ label = "ml:hasParamIgnoreImplicitZeros" ];
	"ml:KBinsDiscretizer" -> "xsd:int" [ label = "ml:hasParamNBins" ];
	"ml:PolynomialFeatures" -> "xsd:int" [ label = "ml:hasParamDegree" ];
	"ml:OneHotEncoder" -> "xsd:float" [ label = "ml:hasParamMinFrequency" ];
	"ml:LabelBinarizer" -> "xsd:boolean" [ label = "ml:hasParamSparseOutput" ];
	"ml:RobustScaler" -> "xsd:string" [ label = "ml:hasParamQuantileRange" ];
	"ml:DataProcessing" -> "ml:LabelBinarizer" [ label = "ml:hasDataProcessingMethod" ];
	"ml:PolynomialFeatures" -> "xsd:string" [ label = "ml:hasParamOrder" ];
	"ml:FunctionTransformer" -> "xsd:boolean" [ label = "ml:hasParamCheckInverse" ];
	"ml:KBinsDiscretizer" -> "xsd:string" [ label = "ml:hasParamEncode" ];
	"ml:TargetEncoder" -> "xsd:boolean" [ label = "ml:hasParamShuffle" ];
	"ml:FunctionTransformer" -> "xsd:boolean" [ label = "ml:hasParamAcceptSparse" ];
	"ml:PolynomialFeatures" -> "xsd:boolean" [ label = "ml:hasParamIncludeBias" ];
	"ml:LabelBinarizer" -> "xsd:int" [ label = "ml:hasParamPosLabel" ];
	"ml:FunctionTransformer" -> "xsd:string" [ label = "ml:hasParamInvKwArgs" ];
	"ml:Normalizer" -> "xsd:string" [ label = "ml:hasParamNorm" ];
	"ml:LabelBinarizer" -> "xsd:int" [ label = "ml:hasParamNegLabel" ];
	"ml:RobustScaler" -> "xsd:boolean" [ label = "ml:hasParamWithCentering" ];
	"ml:QuantileTransformer" -> "xsd:boolean" [ label = "ml:hasParamCopy" ];
	"ml:FunctionTransformer" -> "xsd:string" [ label = "ml:hasParamFunc" ];
	"ml:KBinsDiscretizer" -> "xsd:int" [ label = "ml:hasParamRandomState" ];
	"ml:OneHotEncoder" -> "xsd:string" [ label = "ml:hasParamDrop" ];
	"ml:OneHotEncoder" -> "xsd:string" [ label = "ml:hasParamCategories" ];
	"ml:StandardScaler" -> "xsd:boolean" [ label = "ml:hasParamWithMean" ];
	"ml:TargetEncoder" -> "xsd:string" [ label = "ml:hasParamTargetType" ];
	"ml:OneHotEncoder" -> "xsd:int" [ label = "ml:hasParamMaxCategories" ];
	"ml:KBinsDiscretizer" -> "xsd:string" [ label = "ml:hasParamDtype" ];
	"ml:Binarizer" -> "xsd:float" [ label = "ml:hasParamThreshold" ];
	"ml:KBinsDiscretizer" -> "xsd:string" [ label = "ml:hasParamStrategy" ];
	"ml:OrdinalEncoder" -> "xsd:int" [ label = "ml:hasParamUnknownValue" ];
	"ml:FunctionTransformer" -> "xsd:string" [ label = "ml:hasParamInverseFunc" ];

}
