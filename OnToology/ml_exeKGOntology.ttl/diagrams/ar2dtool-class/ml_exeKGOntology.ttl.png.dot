digraph ar2dtool_diagram { 
rankdir=LR;
size="1501"
node [shape = rectangle, color="orange"]; "ml:DataInTransformer" "ml:DataInPredictedY" "ml:Concatenation" "ml:DataInDataSplittingY" "ml:DataInTrainY" "ml:PerformanceCalculationMethod" "ml:DataOutSplittedTestDataX" "ml:ConcatenationMethod" "ml:DataOutScore" "ml:PrepareTransformer" "ml:DataInTestModel" "ml:DataInRealY" "ml:Test" "ml:DataSplitting" "ml:DataOutConcatenatedData" "ml:DataInTrainX" "ml:DataInDataSplittingX" "ml:DataOutTransformed" "ml:DataSplittingMethod" "ml:Train" "ml:PerformanceCalculation" "ml:DataOutTransformer" "ml:DataOutTrainModel" "ml:DataInToTransform" "ml:DataOutPredictedValueTest" "ml:DataOutSplittedTrainDataY" "ml:DataOutSplittedTrainDataX" "ml:DataInToPrepareTransformer" "ml:DataInTestX" "ml:DataOutSplittedTestDataY" "ml:DataInConcatenation" "ml:Transform" ; /*classes style*/
	"ml:hasConcatenationMethod" -> "ds:hasMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:DataInTestX" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataInTestX" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataInTestX" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:hasTestOutput" -> "ds:hasOutput" [ label = "rdfs:subPropertyOf" ];
	"ml:DataOutSplittedTestDataY" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataOutSplittedTestDataY" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataOutSplittedTestDataY" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:DataOutSplittedTrainDataY" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataOutSplittedTrainDataY" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataOutSplittedTrainDataY" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:DataOutPredictedValueTest" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataOutPredictedValueTest" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:hasPerformanceCalculationInput" -> "ds:hasInput" [ label = "rdfs:subPropertyOf" ];
	"ml:hasPerformanceCalculationOutput" -> "ds:hasOutput" [ label = "rdfs:subPropertyOf" ];
	"ml:hasDataSplittingInput" -> "ds:hasInput" [ label = "rdfs:subPropertyOf" ];
	"ml:DataOutSplittedTestDataX" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataOutSplittedTestDataX" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataOutSplittedTestDataX" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:hasTrainMethod" -> "ds:hasMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:DataOutSplittedTrainDataX" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataOutSplittedTrainDataX" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataOutSplittedTrainDataX" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:hasConcatenationInput" -> "ds:hasInput" [ label = "rdfs:subPropertyOf" ];
	"ml:DataInDataSplittingY" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataInDataSplittingY" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataInDataSplittingY" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:DataInTestModel" -> "ds:Model" [ label = "ds:hasDataStructure" ];
	"ml:hasConcatenationOutput" -> "ds:hasOutput" [ label = "rdfs:subPropertyOf" ];
	"ml:DataOutTransformer" -> "ds:DataTransformer" [ label = "ds:hasDataStructure" ];
	"ml:DataInToTransform" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataInToTransform" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataInToTransform" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:hasPrepareTransformerMethod" -> "ds:hasMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasDataSplittingMethod" -> "ds:hasMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:DataInDataSplittingX" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataInDataSplittingX" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataInDataSplittingX" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:DataInTransformer" -> "ds:DataTransformer" [ label = "ds:hasDataStructure" ];
	"ml:hasTestInput" -> "ds:hasInput" [ label = "rdfs:subPropertyOf" ];
	"ml:hasTrainOutput" -> "ds:hasOutput" [ label = "rdfs:subPropertyOf" ];
	"ml:DataOutScore" -> "ds:SingleValue" [ label = "ds:hasDataStructure" ];
	"ml:DataInConcatenation" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataInTrainY" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataInTrainY" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataInTrainY" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:hasTransformInput" -> "ds:hasInput" [ label = "rdfs:subPropertyOf" ];
	"ml:hasTestMethod" -> "ds:hasMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:DataInToPrepareTransformer" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataInToPrepareTransformer" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataInToPrepareTransformer" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:DataOutTrainModel" -> "ds:Model" [ label = "ds:hasDataStructure" ];
	"ml:hasPerformanceCalculationMethod" -> "ds:hasMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:DataInTrainX" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataInTrainX" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataInTrainX" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:hasPrepareTransformerInput" -> "ds:hasInput" [ label = "rdfs:subPropertyOf" ];
	"ml:DataOutTransformed" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataOutTransformed" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataOutTransformed" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:hasTrainInput" -> "ds:hasInput" [ label = "rdfs:subPropertyOf" ];
	"ml:hasPrepareTransformerOutput" -> "ds:hasOutput" [ label = "rdfs:subPropertyOf" ];
	"ml:hasDataSplittingOutput" -> "ds:hasOutput" [ label = "rdfs:subPropertyOf" ];
	"ml:DataInPredictedY" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataInPredictedY" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:DataOutConcatenatedData" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:hasTransformOutput" -> "ds:hasOutput" [ label = "rdfs:subPropertyOf" ];
	"ml:DataInRealY" -> "ds:Tabular" [ label = "ds:hasDataStructure" ];
	"ml:DataInRealY" -> "ds:Vector" [ label = "ds:hasDataStructure" ];
	"ml:DataInRealY" -> "ds:Matrix" [ label = "ds:hasDataStructure" ];
	"ml:Transform" -> "ml:DataInToTransform" [ label = "ml:hasTransformInput" ];
	"ml:Test" -> "ml:DataOutPredictedValueTest" [ label = "ml:hasTestOutput" ];
	"ml:Concatenation" -> "ml:DataInConcatenation" [ label = "ml:hasConcatenationInput" ];
	"ml:Train" -> "ml:DataOutTrainModel" [ label = "ml:hasTrainOutput" ];
	"ml:PrepareTransformer" -> "ml:DataOutTransformer" [ label = "ml:hasPrepareTransformerOutput" ];
	"ml:PerformanceCalculation" -> "ml:PerformanceCalculationMethod" [ label = "ml:hasPerformanceCalculationMethod" ];
	"ml:Test" -> "owl:Thing" [ label = "ml:hasTestMethod" ];
	"ml:PrepareTransformer" -> "owl:Thing" [ label = "ml:hasPrepareTransformerMethod" ];
	"ml:PrepareTransformer" -> "ml:DataInToPrepareTransformer" [ label = "ml:hasPrepareTransformerInput" ];
	"ml:PerformanceCalculation" -> "ml:DataOutScore" [ label = "ml:hasPerformanceCalculationOutput" ];
	"ml:DataSplitting" -> "ml:DataSplittingMethod" [ label = "ml:hasDataSplittingMethod" ];
	"ml:Test" -> "ml:DataInTestModel" [ label = "ml:hasTestInput" ];
	"ml:Concatenation" -> "ml:ConcatenationMethod" [ label = "ml:hasConcatenationMethod" ];
	"ml:DataSplitting" -> "ml:DataOutSplittedTestDataX" [ label = "ml:hasDataSplittingOutput" ];
	"ml:PerformanceCalculation" -> "ml:DataInPredictedY" [ label = "ml:hasPerformanceCalculationInput" ];
	"ml:Train" -> "owl:Thing" [ label = "ml:hasTrainMethod" ];
	"ml:DataSplitting" -> "ml:DataInDataSplittingX" [ label = "ml:hasDataSplittingInput" ];
	"ml:Concatenation" -> "ml:DataOutConcatenatedData" [ label = "ml:hasConcatenationOutput" ];
	"ml:Transform" -> "ml:DataOutTransformed" [ label = "ml:hasTransformOutput" ];
	"ml:Train" -> "ml:DataInTrainX" [ label = "ml:hasTrainInput" ];

}
